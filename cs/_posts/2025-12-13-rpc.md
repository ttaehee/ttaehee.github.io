---
title: gRPC, Protobuf 정리
excerpt: gRPC 전체 Flow 정리
---

<br/>

- 이직 했다 파릇한 한달차임    
  rpc 처음 접해보아서 파악한거 안까먹게 가볍게 정리해보기   

<br/>

## RPC (Remote Procedure Call)
네트워크 통신(HTTP, 요청/응답, 직렬화 등)을 숨기고 로컬함수 호출처럼 보이도록 추상화한 개념  

= 원격호출을 함수호출처럼 취급하자 라는 아이디어

<br/><br/>

## gRPC

그 아이디어를 실제 동작하게 만드는 구현체    
구글이 아래 기술 조합을 묶어 RPC 개념을 구현해 제공하는 프레임워크   

- 전송방식 : HTTP/2

- 직렬화방식 : Protocol Buffers(Protobuf)
  
- 인터페이스 정의 방식 : proto 언어로 message(데이터 구조)/ service(api 목록 + 요청응답 구조) 스펙 정의
  
- 호출 방식 : proto 파일 기반으로 자동 생성된 stub 통해 RPC 호출

<br/><br/>

### Protocol Buffers(Protobuf)
구글이 만든 데이터 직렬화 기술    
gRPC 가 기본 직렬화 방식으로 protobuf 씀 = protobuf 가 데이터를 binary 로 만들고 gRPC 가 그걸 운반함    

<br/>

**구성요소**    

- proto : idl (Interface Definition Language) 중 하나   

   - 이 언어로 작성한 산출물 `.proto` 파일 : 기계가 읽는, 코드 생성을 위한 스펙문서    
     = 이 gRPC 서비스랑 데이터는 이렇게 생겼어 이 스펙대로 서버, 클라이언트 코드 만들면돼         

- protoc : 코드 생성기

  - proto 파일을 읽어 실제 소스코드(Java/Go/Python 등) 자동 생성    
    (bytecode 변환은 각 언어의 컴파일러(javac 등)가 그대로 담당)
    
  - 생성 대상
    - 메시지 클래스
    - 서버용 추상클래스 ImplBase
    - 클라이언트용 Stub   

- 런타임 라이브러리 (protobuf runtime) : 생성된 코드가 실제로 동작하도록 지원하는 엔진
  
  - 메시지 직렬화/역직렬화 (객체 <-> binary buffer), 필드 관리, 타입 검증, 빌더 로직 담당   
    
   - 언어별로 별도 제공됨
     

- binary buffer : protobuf의 binary format을 사용해서 직렬화한 실제 결과물

  - byte[] 형태의 데이터로, 불필요한 텍스트 없고 스키마 고정되어 있음 (= 타입 추론없이 바로 파싱 가능) => 용량 작고 파싱 속도 빠름   
 

<br/><br/>

### gRPC 전체 Flow

<br/>

**1. 개발자가 proto 정의**   
message, service 스펙을 proto 파일에 정의   

<br/>

↓ protoc : 코드 생성 

<br/>

**2. 자동 생성된 소스코드**   
`ProductServiceGrpc.java` 안에 여러클래스 중첩   

- 메시지 클래스 `ProductRequest`, `ProductResponse`
- 서버용 베이스클래스 `ProductServiceGrpc.ProductServiceImplBase` : 단순히 API 틀 만들어주는 역할 -> 서버가 상속해서 실제 비즈니스 로직 구현하는 추상클래스
- 클라이언트용 대리 호출자 `ProductServiceGrpc.ProductServiceBlockingStub` : client에서 API 호출 시 RPC 호출을 gRPC 런타임에 위임하는 프록시

<br/>

↓ javac : 컴파일    

.class   

<br/>

↓ gradle : 패키징    

idl jar    

<br/>

↓ gradle : 업로드 = artifact 배포   

Nexus 에     

<br/><br/>

**3. 서버, 클라이언트에서 사용**   
서버 : idl jar dependency 통해 ProductServiceImplBase 상속해서 비즈니스 로직만 구현

↕ 

gRPC 런타임 : 통신 관리자 (네트워크 통신, 직렬화, HTTP/2, 연결/스트림 관리)     

↕ 

클라이언트 : idl jar dependency 통해 jar 에 포함된 stub 사용해 원격서버 호출    
(코드에선 단순 메서드호출 같아보이게 하는 프록시 = 실제로는 RPC 호출을 가로채 gRPC 런타임에 위임하는 프록시)   


<br/><br/>

참고)  
```text
        Proxy (대리 객체 개념 전체)  
                │    
      ┌─────────┴─────────┐    
      │                   │     
Smart Proxy            Remote Proxy     
(호출 전/후 기능)          (원격 호출)    
      │                   │     
   AOP Proxy            gRPC Stub    
```

<br/><br/>

참고)    
- Spring Boot 환경에서는 `net.devh:grpc-client-spring-boot-starter` 하나로 gRPC 런타임(직렬화, 통신 관련 의존성 : grpc-protobuf, grpc-stub, grpc-netty-shaded) 모두 제공함       

  => Spring Boot에서는 idl jar + gRPC starter 의존성만 추가하면 됨     


<br/><br/>
