---
title: CS) 암호화를 통한 API 통신 및 데이터베이스 저장 과정의 보안 강화
excerpt: encryption algorithm (RSA4096, AES256)
---

<br/>

이번에 새롭게 배포되는 기능에서는 앱과 웹 내에서 개인 민감 정보(주민등록번호 등)를 받는 플로우가 포함되어 있었다     
이에 따라 API 통신 및 데이터베이스 저장 과정에서의 보안 강화가 필수적이었다        
최종적으로 API 통신 보안에는 RSA4096을 적용을, 데이터베이스 저장 보안에는 AES256을 적용하였는데 이를 정리해보겠다      

<br/>

## API 통신 보안 :: 비대칭키 암호화 방식
사용자 데이터를 안전하게 보호하기 위해 통신 과정에서 발생할 수 있는 탈취 등의 외부 공격을 방어하는 것이 중요했다    
단순히 데이터 탈취 자체도 경계해야 하지만, 혹시나 탈취되더라도 복호화가 불가하도록 비대칭키 암호화 방식을 선택했다     
(admin에서는 복호화를 통해 조회가 가능해야했기에 단방향 암호화는 제외하였다)       

비대칭키 암호화는 공개키와 개인키를 이용하여 데이터를 암호화하고 복호화하는 방식으로, 중간자 공격을 차단하는 데 효과적이다   
중간자 공격(man-in-the-middle attack) 같은 상황에서도, 공격자가 암호화된 데이터를 가로채는 것은 가능하지만, 개인키 없이는 의미 있는 데이터를 해석할 수 없기 때문에 탈취된 정보는 쓸모가 없게 된다   

- 공개키 암호화 : client는 server에서 제공된 공개키를 이용해 데이터를 암호화하여 전송
- 개인키 복호화 : server만이 개인키를 통해 이를 복호화 가능

대칭키 방식에 비해 암복호화 연산에 자원 소모가 더 크고 키의 관리가 복잡하지만, 해당 api 에서는 보안의 우선순위가 더 크다고 판단하였고 그 중에서도 필요한 데이터에만 비대칭 암호화를 적용하여 효율성을 유지하면서 보안을 확보하기로 하였다   

<br/>

### 비대칭 암호화 알고리즘   
비대칭 암호화 알고리즘에는 RSA(Rivest Shamir Adleman), ECC(Elliptic Curve Cryptography), DSA(Digital Signature Algorithm) 등이 있다    
일단 DSA는 서명에 최적화된 알고리즘이고 검증에 중점을 두고 있어 이번 목적에 적합하지 않았다       
ECC는 RSA보다 짧은 키 길이로 동일한 보안성을 제공해 자원 효율성에선 좋지만 RSA에 비해 상대적으로 최근에 사용되기 시작하였다      
위의 이유로 좀 더 긴 기간동안 여러 보안 공격에 대한 저항력이 입증된 RSA를 최종적으로 선택하였다 (보안은 안전하게 가야한다는 주의)      
또한 서버 자원이 충분하고 해당 API는 빈번하게 호출되지 않는 최종 단계에서만 사용되기 때문에 성능은 충분하다고 판단했다   

<br/>

### RSA (Rivest-Shamir-Adleman)   
RSA 는 큰 수의 소인수분해 수를 알기 어렵다는 것에 기반한 알고리즘이다 (말이 좀 이상한가)    

<br/>

키 생성 알고리즘
- 서로 다른 두 소수 p, g
  - ex) p = 7, q = 13 
- N = p * q
  - ex) N = 7 * 13 = 91
- K = (p-1) * (q-1)
  - ex) K = (7-1) * (13-1) = 72
- K와 최대공약수가 1인 수(서로소인 수) e (1 < e < K) 찾기
  - ex) K와 서로소인 수 e = 5, 7, 11... 11 선택
- e*d를 K로 나눈 나머지가 1이 되는 d 찾기
  - ex) 11 * d % 72 = 1인 d = 57, 131... 57 선택
- N과 e를 공개한다 공개키: [ N, e ]
  - ex) [ 91, 11 ] 
- d는 키 생성자가 보관한다 개인키: [ N, d]
  - ex) [ 91, 57 ]

<br/>

암/복호화
- 암호화(암호문 생성) : C = P^e mod N
- 복호화(평문 생성) : P = C^d mod N      

<br/>

공개키 [ N, e ]로 부터 비밀키 d를 알아내기 위해서는, N으로 부터 K를 구하면 d를 쉽게 알 수 있다 = 개인키를 알아내려면 N의 소인수분해가 필요하다     
따라서, RSA의 안전성은 소수 p와 q의 선택에 달려 있으며, 이를 위해 2048비트 또는 4096비트 키 길이가 권장된다    
2048비트 키 길이가 오늘날의 표준이지만, 컴퓨터 연산 능력이 계속 향상됨에 따라 비밀키를 유추하는 것이 쉬워지고 있어 4096비트 키를 선택했다   

<br/>

더 긴 키 길이는 암호화 및 복호화에 추가적인 연산을 요구하지만, 위에서 말한것처럼 API 호출 빈도가 낮기 때문에 연산이 자주 이루어지지 않아 성능 저하가 체감될 가능성이 적다         
또한, 서버 자원이 충분한 경우 이러한 추가 연산을 감당할 수 있어 성능에 미치는 영향이 크지 않으므로 더 긴 키 길이가 문제가 되지 않는다고 판단했다      
실제로 해당 api 요청 테스트 시, 처리 속도가 크게 차이나지 않았다    

<br/><br/>

// AES 추가 작성 필요

Reference     
- [ICPA::RSA](https://www.youtube.com/watch?v=kGUlfVpIfaQ)
- [Veritas::RSA](https://www.veritas.com/ko/kr/information-center/rsa-encryption)

<br/>
