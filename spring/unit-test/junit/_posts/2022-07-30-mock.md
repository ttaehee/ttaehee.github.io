---
title: Spring) Mock Test
excerpt: 단위테스트
---

## Business Layer & mock
userService가 userRepository에 의존하고 있기 때문에,   
userService의 테스트코드 실행 시 `실제 DB와의 연동`이 불가피함  
=> userRepository를 가짜객체로 만들기  
=> DB와의 연동이 일어나지 않아 효율적! <br/><br/>


### 유저목록 조회 단위테스트  

```java
@Mock  // userRepository는 가짜 객체가 됨
private UserRepository userRepository;

@InjectMocks  // userService가 의존하는 Mock 객체인 userRepository를 주입(DI)받음
private UserService userService;

@Test
void getUsers() throws Exception {
    // given
    List<User> users = getUserList();

    // when : userRepository는 빈껍데기인 가짜객체이기 때문에 아무런 기능을 하지 않음 따라서 특정 메서드 호출에 대한 반환값 명시필요
    doReturn(users).when(userRepository).findAll(); 

    // then : userService.findUsers() 메서드는 userRepository.findAll() 메서드가 호출된 반환값을 반환, 그렇기 때문에 users가 위에서 명시한 것처럼 users 가 반환됨
    List<User> userList = userService.findUsers();

    assertThat(userList.size(), is(users.size())); // 사이즈가 같음을 확인
}
```

<br/>

### MOckMVC로 Controller API Test  
API의 경우 함수실행을 위해 메소드가 아닌 API가 호출됨  
-> `API요청을 받아 전달`하기 위한 별도객체 필요  
-> Spring Test에서는 이를 위해 MockMVC 지원

- MockMVC : 애플리케이션을 서버에 배포하지 않고도 Spring 의 MVC test 가능하게 해줌  
  Controller에 대한 API를 받아 넘겨줄 수 있음  

```java
@Autowired
private MockMvc mockMvc;

@Test
void 코멘트_목록_가져오기() throws Exception{
    Long userId = 2L;
    Long postId = 4L;

    mockMvc.perform(get("/api/user/"+userId+"/post/"+postId+"/comment/list")
            .accept(MediaType.APPLICATION_JSON))
            .andExpect(status().isOk())
            .andDo(print());
}
```

<br/>

지난번 예시보다 쉬운 예시  
둘 다 해보기!

<br/>

Reference  
https://ronick-grammer.github.io/spring/Spring-Mock-%ED%85%8C%EC%8A%A4%ED%8A%B8/
