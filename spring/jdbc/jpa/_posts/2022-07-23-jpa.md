---
title: JDBC) JPA
excerpt: Java Persistence API
---

# JPA (Java Persistence API)
- 현재 자바 진영의 ORM 기술 표준
- 자바어플리케이션에서 `관계형 데이터베이스를 사용하는 방식`을 정의한 인터페이스의 모음
  - 즉, 실제로 동작하는 것이 아님
  - JPA를 구현한 구현체: `Hibernate`, EclipseLink, DataNucleus <br/><br/>

### ORM (Object-Relational Mapping)
객체관계매핑
- 객체는 객체대로 설계
- 관계형데이터베이스는 관계형데이터베이스대로 설계   
=> ORM 프레임워크가 중간에서 매핑해줌

### JPA 동작과정
![제목 없음](https://user-images.githubusercontent.com/103614357/180476108-7c335fe7-f4f2-44d3-b14f-1cfbd7c59d78.png)  
- application 과 JDBC 사이에서 동작  
- 개발자가 직접 JDBC API 를 쓰는것이 아님
  - 개발자가 JPA 사용하면   
  -> JPA 내부에서 JDBC API를 사용하여 SQL 호출 -> DB와 통신 <br/><br/>

### JPA 저장과정
![제목 없음](https://user-images.githubusercontent.com/103614357/180476754-9358fbec-2e11-4e90-8beb-0e4acefee8eb.png)  
MemberDAO에서 객체저장  
1. 개발자가 JPA에게 Member 객체 넘김
2. JPA   
   1) Member entity 분석  
   2) INSERT SQL 생성  
   3) JDBC API 를 사용하여 SQL을 DB에 날림 <br/><br/> 


### JPA 조회과정
![제목 없음](https://user-images.githubusercontent.com/103614357/180476841-84feaf30-8319-429a-b4b1-ffb3545ef64d.png)  
Member 객체조회  
1. 개발자가 Member 의 pk값을 JPA에게 넘김
2. JPA  
   1) entity의 매핑정보를 바탕으로 적절한 SELECT SQL 생성    
   2) JDBC API 를 사용하여 SQL을 DB에 날림    
   3) DB에서 결과받음   
   4) ResultSet(결과)를 객체에 매핑    

=> 쿼리가 JPA 만들어줌 -> Object와 RDB 간의 패러다임 불일치 해결 <br/><br/>

## JPA 사용해야하는 이유!
- SQL 중심개발에서 객체중심으로 개발
- 생산성
  - 간단한 CRUD
    - INSERT : `jpa.persist(member)`
    - SELECT : `Member member = jpa.find(memberId)`
    - UPDATE : `member.setName("변경이름")`
    - DELETE : `jpa.remove(member)`
   - 객체 변경 시 알아서 DB에 UPDATE 쿼리가 나감
- 유지보수가 쉬움
  - 기존 : 필드 추가 + 모든 SQL 수정
  - JPA : 필드만 추가 (SQL은 JPA가 처리)
- Object와 RDB간의 패러다임 불일치 해결
![제목 없음](https://user-images.githubusercontent.com/103614357/180593391-dec05c9d-2b36-4381-af0c-2116fb90a498.png)


## JPA 단점
- 설계가 잘못된 경우, 오히려 속도 저하
- 복잡한 쿼리는 속도를 위해 별도의 튜닝 필요 -> 결국 SQL문 써야할 수도 있음


Reference  
https://www.inflearn.com/course/ORM-JPA-Basic#
https://gmlwjd9405.github.io/2019/08/04/what-is-jpa.html
